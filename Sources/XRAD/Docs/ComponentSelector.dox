// Doxygen
#error Файл с документацией, не компилируется
/*!
\page pg_ComponentSelector Выбор компонент данных контейнеров

Контейнеры могут содержать данные, делимые на компоненты. К примеру, это
комплекснозначные данне ComplexSample, в которых компонентами являются
действительная и мнимая части, RGB-данные, в которых компонентами являются R,
G и B.

Для извлечения компоненты используются функторы ComponentSelector.
Фнуктор ComponentSelector должен иметь operator() от _указателя_ на тип данных
контейнера и возвращать _указатель_ на тип данных компоненты.

Например, функтор для извлечения действительной части из
ComplexSample&lt;double, double&gt; выглядит следующим образом:

~~~~
auto complex_to_real = [](ComplexSample<double, double> *data)
{
	return &data->re;
};
~~~~

Замечание. Функтор может быть и обычной функцией.

В случае константных данных функтор должен принимать указатель на константные
данные и возвращать указатель на константные данные:

~~~~
const double *ComplexToRealConst(const ComplexSample<double, double> *data)
{
	return &data->re;
}
~~~~

Константность типов аргумента и возвращаемого значения сейчас используются
в двух местах:
- При получении указателя на данные компоненты происходит вызов функтора от
указателя на данные контейнера (один раз, для получения указателя на нулевой
элемент контейнера).
- По типу возвращаемого значения функтора может автоматически
определяться тип контейнера для компоненты данных, если тип контейнера
компоненты не задан явно и не выводится из типов аргументов функции.

Недопутимо использовать функтор ComponentSelector для получения указателя на
связанные данные, не лежащие внутри value_type контейнера. Это приведет к
неопределенному поведению программы.

Замечание. Из-за особенности текущей реализации DataOwner размер типа (sizeof)
данных контейнера должен быть кратен размеру типа данных компоненты. На этапе
компиляции производится проверка этого условия (static_assert).
Данное ограничение можно снять, доработав DataOwner.
*/
